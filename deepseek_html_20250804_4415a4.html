<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA复制过程模拟</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-image: linear-gradient(to right top, #051937, #004d7a, #008793, #00bf72, #a8eb12);
            min-height: 100vh;
            color: white;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .container {
            display: flex;
            width: 100%;
            max-width: 1400px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .toolbox {
            width: 250px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .tool-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .enzymes, .bases {
            width: 100%;
            margin-bottom: 20px;
        }
        
        .enzyme-item, .base-item {
            margin: 10px 0;
            text-align: center;
        }
        
        .enzyme, .base {
            display: inline-block;
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }
        
        .enzyme:hover, .base:hover {
            transform: scale(1.05);
        }
        
        .enzyme {
            background-color: #3498db;
            color: white;
            padding: 10px 15px;
        }
        
        .base {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }
        
        .base.A {
            background-color: #e74c3c;
            color: white;
        }
        
        .base.T {
            background-color: #3498db;
            color: white;
        }
        
        .base.C {
            background-color: #f1c40f;
            color: black;
        }
        
        .base.G {
            background-color: #2ecc71;
            color: white;
        }
        
        .simulation-area {
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            position: relative;
            height: 700px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .status-bar {
            width: 100%;
            max-width: 1400px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            padding: 10px 20px;
            background-color: #9b59b6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .control-btn:hover {
            background-color: #8e44ad;
        }
        
        #dna-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 400px;
        }
        
        .helix-path {
            fill: none;
            stroke-width: 4;
        }
        
        .helix-path.top {
            stroke: #3498db;
        }
        
        .helix-path.bottom {
            stroke: #e74c3c;
        }
        
        .dna-base {
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .dna-base:hover {
            transform: scale(1.1);
        }
        
        .base-label {
            font-family: Arial, sans-serif;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            fill: white;
        }
        
        .bond {
            stroke: white;
            stroke-width: 2;
        }
        
        .hydrogen-bond {
            stroke: #f1c40f;
            stroke-width: 1.5;
            stroke-dasharray: 5,5;
        }
        
        .new-strand {
            stroke: #2ecc71;
            stroke-width: 3;
            fill: none;
        }
        
        .instruction {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            max-width: 1400px;
            width: 100%;
        }
        
        .instruction h3 {
            margin-top: 0;
        }
        
        .template-strand-label, .coding-strand-label {
            font-family: Arial, sans-serif;
            font-weight: bold;
            text-anchor: middle;
            fill: white;
            font-size: 14px;
        }
        
        .unwound-area {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        .strand {
            stroke-width: 3;
            fill: none;
        }
        
        .template-strand {
            stroke: #3498db;
        }
        
        .coding-strand {
            stroke: #e74c3c;
        }
        
        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 24px;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <h1>DNA复制过程模拟</h1>
    
    <div class="instruction">
        <h3>操作说明</h3>
        <p>1. 将"DNA解旋酶"拖拽到双螺旋DNA上，观察DNA解旋过程</p>
        <p>2. DNA解旋后，会显示两条单链：上面为编码链(5'→3')，下面为模板链(3'→5')</p>
        <p>3. 从碱基工具箱中拖拽A、T、C、G碱基到对应的DNA链上进行配对（A-T、C-G）</p>
        <p>4. <strong>重要：上面的编码链(蓝色)只能从右向左复制，下面的模板链(红色)只能从左向右复制</strong></p>
        <p>5. 配对正确后，碱基之间会形成氢键连接</p>
        <p>6. 完成所有碱基配对后，新形成的链会与原来的DNA单链螺旋形成新的DNA分子</p>
    </div>
    
    <div class="status-bar" id="status">
        准备就绪：请将DNA解旋酶拖拽到DNA双螺旋结构上开始复制过程
    </div>
    
    <div class="control-buttons">
        <button class="control-btn" id="reset-btn">重置模拟</button>
        <button class="control-btn" id="help-btn">显示帮助</button>
    </div>
    
    <div class="container">
        <div class="toolbox">
            <div class="tool-title">酶工具箱</div>
            <div class="enzymes">
                <div class="enzyme-item">
                    <div class="enzyme" draggable="true" data-type="helicase">DNA解旋酶</div>
                </div>
            </div>
            
            <div class="tool-title">碱基工具箱</div>
            <div class="bases">
                <div class="base-item">
                    <div class="base A" draggable="true" data-base="A">A</div>
                    <div class="base T" draggable="true" data-base="T">T</div>
                    <div class="base C" draggable="true" data-base="C">C</div>
                    <div class="base G" draggable="true" data-base="G">G</div>
                </div>
            </div>
        </div>
        
        <div class="simulation-area">
            <div id="dna-container">
                <svg id="dna-svg" width="100%" height="100%">
                    <!-- DNA双螺旋将在这里动态绘制 -->
                </svg>
            </div>
            
            <div class="unwound-area" id="unwound-area">
                <svg id="unwound-svg" width="100%" height="100%">
                    <!-- 解旋后的DNA将在这里动态绘制 -->
                </svg>
            </div>
            
            <div class="success-message" id="success-message">
                DNA复制成功！形成了两条新的双螺旋结构
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 配置参数
            const config = {
                helix: {
                    radius: 60,
                    turns: 4,
                    segments: 200,
                    centerX: 400,
                    centerY: 200
                },
                strand: {
                    coding: "ATGCCATCGTTGGCCATCATGTAA",
                    template: "TACGGTAGCAACCGGTAGTACATT"
                }
            };

            // 状态变量
            let isUnwound = false;
            let replicationComplete = false;
            let currentDragging = null;
            let templateStrandBases = []; // 存储模板链上的碱基
            let codingStrandBases = [];  // 存储编码链上的碱基
            let newTemplateStrand = [];  // 新合成的与模板链配对的链
            let newCodingStrand = [];    // 新合成的与编码链配对的链
            let basePairs = { 'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C' };
            let unwoundStart = 0;
            let unwoundEnd = 0;

            // 获取DOM元素
            const dnaSvg = document.getElementById('dna-svg');
            const unwoundSvg = document.getElementById('unwound-svg');
            const dnaContainer = document.getElementById('dna-container');
            const unwoundArea = document.getElementById('unwound-area');
            const statusBar = document.getElementById('status');
            const resetBtn = document.getElementById('reset-btn');
            const helpBtn = document.getElementById('help-btn');
            const successMessage = document.getElementById('success-message');

            // 初始化
            init();

            // 初始化函数
            function init() {
                drawHelix();
                setupEventListeners();
            }

            // 绘制DNA双螺旋
            function drawHelix() {
                dnaSvg.innerHTML = '';
                // 动态获取容器宽度并计算中心位置
                const containerWidth = dnaContainer.clientWidth;
                const dynamicCenterX = containerWidth / 2;
                const { radius, turns, segments, centerY } = config.helix;

                // 创建第一条螺旋路径 (编码链)
                const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData1 = '';

                // 创建第二条螺旋路径 (模板链)
                const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData2 = '';

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const angle = t * 2 * Math.PI * turns;
                    // 调整水平范围，使其完全显示在容器内
                    const x = dynamicCenterX - 150 + t * 300; // 从dynamicCenterX-150到dynamicCenterX+150，总宽度300

                    // 第一条螺旋 (编码链)
                    const y1 = centerY + radius * Math.cos(angle);
                    const z1 = radius * Math.sin(angle);

                    // 第二条螺旋 (模板链，与第一条相位差180度)
                    const y2 = centerY + radius * Math.cos(angle + Math.PI);
                    const z2 = radius * Math.sin(angle + Math.PI);

                    // 透视投影 (简单模拟3D效果)
                    const scale1 = 1 - z1 / 400;
                    const scale2 = 1 - z2 / 400;

                    const py1 = centerY + (y1 - centerY) * scale1;
                    const py2 = centerY + (y2 - centerY) * scale2;

                    if (i === 0) {
                        pathData1 += 'M' + x + ',' + py1;
                        pathData2 += 'M' + x + ',' + py2;
                    } else {
                        pathData1 += ' L' + x + ',' + py1;
                        pathData2 += ' L' + x + ',' + py2;
                    }
                }

                // 设置第一条路径属性 (编码链)
                path1.setAttribute('d', pathData1);
                path1.setAttribute('class', 'helix-path top');
                dnaSvg.appendChild(path1);

                // 设置第二条路径属性 (模板链)
                path2.setAttribute('d', pathData2);
                path2.setAttribute('class', 'helix-path bottom');
                dnaSvg.appendChild(path2);

                // 添加连接线 (碱基对)
                for (let i = 0; i <= 20; i++) {
                    const t = i / 20;
                    const angle = t * 2 * Math.PI * turns;
                    // 调整连接线的水平位置
                    const x = dynamicCenterX - 150 + t * 300;

                    // 第一条螺旋点
                    const y1 = centerY + radius * Math.cos(angle);
                    const z1 = radius * Math.sin(angle);

                    // 第二条螺旋点
                    const y2 = centerY + radius * Math.cos(angle + Math.PI);
                    const z2 = radius * Math.sin(angle + Math.PI);

                    // 透视投影
                    const scale1 = 1 - z1 / 400;
                    const scale2 = 1 - z2 / 400;

                    const py1 = centerY + (y1 - centerY) * scale1;
                    const py2 = centerY + (y2 - centerY) * scale2;

                    // 创建连接线
                    const bond = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    bond.setAttribute('x1', x);
                    bond.setAttribute('y1', py1);
                    bond.setAttribute('x2', x);
                    bond.setAttribute('y2', py2);
                    bond.setAttribute('class', 'bond');
                    dnaSvg.appendChild(bond);
                }

                // 添加DNA标签
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', dynamicCenterX);
                label.setAttribute('y', centerY - 100);
                label.setAttribute('class', 'base-label');
                label.setAttribute('font-size', '24px');
                label.textContent = 'DNA双螺旋结构';
                dnaSvg.appendChild(label);
            }

            // 解旋DNA
            function unwindDNA(start, end) {
                unwoundSvg.innerHTML = '';
                templateStrandBases = [];
                codingStrandBases = [];
                unwoundStart = start;
                unwoundEnd = end;

                const baseSize = 24;
                const startX = 100;
                const centerY = 200;
                const strandDistance = 150;
                const spacing = 30;

                // 绘制解旋区域标记
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                marker.setAttribute('x', startX + start * spacing);
                marker.setAttribute('y', centerY - strandDistance/2 - 50);
                marker.setAttribute('width', (end - start) * spacing);
                marker.setAttribute('height', strandDistance + 100);
                marker.setAttribute('fill', 'rgba(255, 255, 255, 0.1)');
                marker.setAttribute('stroke', '#3498db');
                marker.setAttribute('stroke-width', '2');
                unwoundSvg.appendChild(marker);

                // 绘制编码链碱基 (仅解旋区域)
                for (let i = start; i < end; i++) {
                    if (i < config.strand.coding.length) {
                        const base = config.strand.coding[i];
                        const x = startX + i * spacing;
                        const y = centerY - strandDistance/2;

                        // 创建碱基矩形
                        const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        baseRect.setAttribute('x', x - baseSize/2);
                        baseRect.setAttribute('y', y - baseSize/2 - 30);
                        baseRect.setAttribute('width', baseSize);
                        baseRect.setAttribute('height', baseSize);
                        baseRect.setAttribute('rx', '4');
                        baseRect.setAttribute('ry', '4');
                        baseRect.setAttribute('fill', getBaseColor(base));
                        baseRect.setAttribute('stroke', 'white');
                        baseRect.setAttribute('stroke-width', '1.5');
                        baseRect.setAttribute('class', 'dna-base');
                        baseRect.setAttribute('data-base', base);
                        baseRect.setAttribute('data-index', i);
                        unwoundSvg.appendChild(baseRect);

                        // 创建碱基标签
                        const baseText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        baseText.setAttribute('x', x);
                        baseText.setAttribute('y', y - 30);
                        baseText.setAttribute('class', 'base-label');
                        baseText.textContent = base;
                        unwoundSvg.appendChild(baseText);

                        // 存储碱基信息
                        codingStrandBases.push({
                            base: base,
                            element: baseRect,
                            x: x,
                            y: y - 30,
                            paired: false
                        });
                    }
                }

                // 绘制模板链碱基 (仅解旋区域)
                for (let i = start; i < end; i++) {
                    if (i < config.strand.template.length) {
                        const base = config.strand.template[i];
                        const x = startX + i * spacing;
                        const y = centerY + strandDistance/2;

                        // 创建碱基矩形
                        const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        baseRect.setAttribute('x', x - baseSize/2);
                        baseRect.setAttribute('y', y - baseSize/2 + 30);
                        baseRect.setAttribute('width', baseSize);
                        baseRect.setAttribute('height', baseSize);
                        baseRect.setAttribute('rx', '4');
                        baseRect.setAttribute('ry', '4');
                        baseRect.setAttribute('fill', getBaseColor(base));
                        baseRect.setAttribute('stroke', 'white');
                        baseRect.setAttribute('stroke-width', '1.5');
                        baseRect.setAttribute('class', 'dna-base');
                        baseRect.setAttribute('data-base', base);
                        baseRect.setAttribute('data-index', i);
                        unwoundSvg.appendChild(baseRect);

                        // 创建碱基标签
                        const baseText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        baseText.setAttribute('x', x);
                        baseText.setAttribute('y', y + 30);
                        baseText.setAttribute('class', 'base-label');
                        baseText.textContent = base;
                        unwoundSvg.appendChild(baseText);

                        // 存储碱基信息
                        templateStrandBases.push({
                            base: base,
                            element: baseRect,
                            x: x,
                            y: y + 30,
                            paired: false
                        });
                    }
                }

                // 绘制未解旋部分的双螺旋示意
                const helixGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                unwoundSvg.appendChild(helixGroup);

                const startUnwoundX = startX + end * spacing;
                const remainingLength = Math.max(config.strand.coding.length, config.strand.template.length) - end;

                if (remainingLength > 0) {
                    // 绘制未解旋的双螺旋路径
                    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathData1 = 'M' + startUnwoundX + ',' + (centerY - 20);
                    let pathData2 = 'M' + startUnwoundX + ',' + (centerY + 20);

                    for (let i = 1; i <= remainingLength; i++) {
                        const x = startUnwoundX + i * spacing;
                        const phase = i * 0.5;
                        pathData1 += ' C' + (x - spacing/2) + ',' + (centerY - 20 - Math.sin(phase) * 15) + ' ' + (x - spacing/2) + ',' + (centerY - 20 + Math.sin(phase) * 15) + ' ' + x + ',' + (centerY - 20);
                        pathData2 += ' C' + (x - spacing/2) + ',' + (centerY + 20 + Math.sin(phase) * 15) + ' ' + (x - spacing/2) + ',' + (centerY + 20 - Math.sin(phase) * 15) + ' ' + x + ',' + (centerY + 20);
                    }

                    path1.setAttribute('d', pathData1);
                    path1.setAttribute('stroke', '#e74c3c');
                    path1.setAttribute('stroke-width', '4');
                    path1.setAttribute('fill', 'none');
                    helixGroup.appendChild(path1);

                    path2.setAttribute('d', pathData2);
                    path2.setAttribute('stroke', '#3498db');
                    path2.setAttribute('stroke-width', '4');
                    path2.setAttribute('fill', 'none');
                    helixGroup.appendChild(path2);
                }

                // 添加链标签
                const codingLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                codingLabel.setAttribute('x', startX + (start + end) * spacing / 2);
                codingLabel.setAttribute('y', centerY - strandDistance/2 - 70);
                codingLabel.setAttribute('class', 'coding-strand-label');
                codingLabel.textContent = '编码链 (5\' → 3\')';
                unwoundSvg.appendChild(codingLabel);

                const templateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                templateLabel.setAttribute('x', startX + (start + end) * spacing / 2);
                templateLabel.setAttribute('y', centerY + strandDistance/2 + 70);
                templateLabel.setAttribute('class', 'template-strand-label');
                templateLabel.textContent = '模板链 (3\' → 5\')';
                unwoundSvg.appendChild(templateLabel);

                // 更新状态
                isUnwound = true;
                statusBar.textContent = 'DNA部分解旋！请将碱基拖拽到对应的DNA链上进行配对';

                // 初始化新链数组
                if (newTemplateStrand.length === 0) {
                    newTemplateStrand = new Array(config.strand.template.length).fill(null);
                    newCodingStrand = new Array(config.strand.coding.length).fill(null);
                }
            }

            // 获取碱基颜色
            function getBaseColor(base) {
                const colors = {
                    'A': '#e74c3c',
                    'T': '#3498db',
                    'C': '#f1c40f',
                    'G': '#2ecc71'
                };
                return colors[base] || '#ffffff';
            }

            // 设置事件监听器
            function setupEventListeners() {
                // 拖拽酶和碱基
                const draggables = document.querySelectorAll('.enzyme, .base');
                draggables.forEach(draggable => {
                    draggable.addEventListener('dragstart', handleDragStart);
                });

                // DNA区域拖放
                dnaSvg.addEventListener('dragover', handleDragOver);
                dnaSvg.addEventListener('drop', handleDropOnHelix);
                unwoundSvg.addEventListener('dragover', handleDragOver);
                unwoundSvg.addEventListener('drop', handleDropOnUnwound);

                // 重置按钮
                resetBtn.addEventListener('click', resetSimulation);
                
                // 帮助按钮
                helpBtn.addEventListener('click', () => {
                    statusBar.textContent = '请按照操作说明进行：1. 拖拽解旋酶 2. 拖拽碱基配对';
                });
            }

            // 处理拖拽开始
            function handleDragStart(e) {
                currentDragging = e.target;
                e.dataTransfer.setData('text/plain', e.target.getAttribute('data-type') || e.target.getAttribute('data-base'));
                setTimeout(() => {
                    e.target.style.opacity = '0.5';
                }, 0);
            }

            // 处理拖拽经过
            function handleDragOver(e) {
                e.preventDefault();
            }

            // 处理拖放到双螺旋上
            function handleDropOnHelix(e) {
                e.preventDefault();
                currentDragging.style.opacity = '1';

                const data = e.dataTransfer.getData('text/plain');
                const svgRect = e.target.getBoundingClientRect();
                const x = e.clientX - svgRect.left;

                if (data === 'helicase') {
                    // 计算解旋位置
                    const totalWidth = 300; // 双螺旋总宽度
                    const segmentWidth = totalWidth / 3; // 分为三部分
                    let positionSegment;

                    if (x < 100) {
                        positionSegment = 0; // 左侧
                    } else if (x > 200) {
                        positionSegment = 2; // 右侧
                    } else {
                        positionSegment = 1; // 中间
                    }

                    // 根据部分计算解旋长度
                    const maxLength = Math.max(config.strand.coding.length, config.strand.template.length);
                    const segmentLength = Math.ceil(maxLength / 3);
                    let startPosition = positionSegment * segmentLength;
                    const endPosition = Math.min((positionSegment + 1) * segmentLength, maxLength);

                    // 解旋DNA
                    statusBar.textContent = 'DNA解旋中...';
                    setTimeout(() => {
                        unwoundArea.style.display = 'block';
                        dnaSvg.style.display = 'none';
                        unwindDNA(startPosition, endPosition);
                    }, 1000);
                }
            }

            // 处理拖放到解旋DNA上
            function handleDropOnUnwound(e) {
                e.preventDefault();
                currentDragging.style.opacity = '1';

                const data = e.dataTransfer.getData('text/plain');
                const svgRect = e.target.getBoundingClientRect();
                const x = e.clientX - svgRect.left;
                const y = e.clientY - svgRect.top;

                if (['A', 'T', 'C', 'G'].includes(data) && isUnwound && !replicationComplete) {
                    // 放置碱基
                    placeBase(data, x, y);
                } else if (data === 'helicase') {
                    // 在解旋区域放置解旋酶，扩展解旋范围
                    const position = Math.round((x - 100) / 30);
                    const newUnwoundLength = Math.min(position + 5, Math.max(config.strand.coding.length, config.strand.template.length));

                    if (newUnwoundLength > unwoundEnd) {
                        statusBar.textContent = 'DNA继续解旋中...';
                        setTimeout(() => {
                            unwindDNA(unwoundStart, newUnwoundLength);
                        }, 1000);
                    }
                }
            }

            // 放置碱基 (重构后的最终版本)
            function placeBase(base, x, y) {
                const centerY = 200;

                // 判断用户是想与上方链还是下方链配对
                if (y > centerY) {
                    // **目标: 与模板链(下方)配对, 复制方向为从左到右**

                    // 1. 直接找到第一个尚未配对的碱基作为“下一个”目标
                    const nextUnpairedRelativeIndex = templateStrandBases.findIndex(b => !b.paired);

                    // 2. 如果找到了下一个目标
                    if (nextUnpairedRelativeIndex !== -1) {
                        const absoluteIndex = unwoundStart + nextUnpairedRelativeIndex;
                        const templateBase = templateStrandBases[nextUnpairedRelativeIndex];
                        const requiredBase = basePairs[templateBase.base]; // 计算出这个位置唯一需要的碱基

                        // 3. 检查拖动的碱基是否就是所需要的那个
                        if (base === requiredBase) {
                            // 配对成功！
                            addNewBase(base, absoluteIndex, true);
                            templateBase.paired = true;
                            checkReplicationComplete();
                        } else {
                            // 配对失败，提示用户正确的碱基
                            statusBar.textContent = `配对错误！下一个需要配对的是 ${requiredBase}，而不是 ${base}`;
                            setTimeout(() => statusBar.textContent = '请继续配对碱基 (模板链从左向右，编码链从右向左)', 2500);
                        }
                    }
                    // 如果 nextUnpairedRelativeIndex === -1, 说明下方链已全部配对完毕，不执行任何操作。

                } else {
                    // **目标: 与编码链(上方)配对, 复制方向为从右到左**

                    // 1. 从右向左，找到第一个尚未配对的碱基作为“下一个”目标
                    let lastUnpairedRelativeIndex = -1;
                    for (let i = codingStrandBases.length - 1; i >= 0; i--) {
                        if (!codingStrandBases[i].paired) {
                            lastUnpairedRelativeIndex = i;
                            break;
                        }
                    }

                    // 2. 如果找到了下一个目标
                    if (lastUnpairedRelativeIndex !== -1) {
                        const absoluteIndex = unwoundStart + lastUnpairedRelativeIndex;
                        const codingBase = codingStrandBases[lastUnpairedRelativeIndex];
                        const requiredBase = basePairs[codingBase.base]; // 计算出这个位置唯一需要的碱基

                        // 3. 检查拖动的碱基是否就是所需要的那个
                        if (base === requiredBase) {
                            // 配对成功！
                            addNewBase(base, absoluteIndex, false);
                            codingBase.paired = true;
                            checkReplicationComplete();
                        } else {
                            // 配对失败，提示用户正确的碱基
                            statusBar.textContent = `配对错误！下一个需要配对的是 ${requiredBase}，而不是 ${base}`;
                            setTimeout(() => statusBar.textContent = '请继续配对碱基 (模板链从左向右，编码链从右向左)', 2500);
                        }
                    }
                    // 如果 lastUnpairedRelativeIndex === -1, 说明上方链已全部配对完毕，不执行任何操作。
                }
            }



            // 添加新碱基 (修正后)
            function addNewBase(base, index, isTemplateStrand) {
                const baseSize = 24;
                const startX = 100;
                const centerY = 200;
                const strandDistance = 150;
                const spacing = 30;

                const x = startX + index * spacing;
                let y;

                if (isTemplateStrand) {
                    y = centerY + strandDistance / 2 - 40;
                    newTemplateStrand[index] = base;
                } else {
                    y = centerY - strandDistance / 2 + 40;
                    newCodingStrand[index] = base;
                }

                // 创建碱基矩形 (这部分无变化)
                const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                baseRect.setAttribute('x', x - baseSize / 2);
                baseRect.setAttribute('y', y - baseSize / 2);
                baseRect.setAttribute('width', baseSize);
                baseRect.setAttribute('height', baseSize);
                baseRect.setAttribute('rx', '4');
                baseRect.setAttribute('ry', '4');
                baseRect.setAttribute('fill', getBaseColor(base));
                baseRect.setAttribute('stroke', 'white');
                baseRect.setAttribute('stroke-width', '1.5');
                baseRect.setAttribute('class', 'dna-base new-base');
                unwoundSvg.appendChild(baseRect);

                // 创建碱基标签 (这部分无变化)
                const baseText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                baseText.setAttribute('x', x);
                baseText.setAttribute('y', y);
                baseText.setAttribute('class', 'base-label');
                baseText.textContent = base;
                unwoundSvg.appendChild(baseText);

                // 创建氢键 (修正部分)
                const relativeIndex = index - unwoundStart; // **从绝对索引计算相对索引**
                const bondY1 = isTemplateStrand ? templateStrandBases[relativeIndex].y : codingStrandBases[relativeIndex].y;
                const bondY2 = y;

                const bond = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                bond.setAttribute('x1', x);
                bond.setAttribute('y1', bondY1);
                bond.setAttribute('x2', x);
                bond.setAttribute('y2', bondY2);
                bond.setAttribute('class', 'hydrogen-bond');
                unwoundSvg.insertBefore(bond, baseRect); // 将氢键插入到碱基元素之前，避免覆盖
                connectNewStrands(); // 配对一个就尝试连接一次，可以实时看到链的形成
            }


            // 检查复制是否完成
            function checkReplicationComplete() {
                // 检查当前解旋区域内的碱基是否都已配对
                const visibleTemplatePaired = templateStrandBases.every(base => base.paired);
                const visibleCodingPaired = codingStrandBases.every(base => base.paired);
                const allUnwound = unwoundEnd >= Math.max(config.strand.coding.length, config.strand.template.length);

                if (visibleTemplatePaired && visibleCodingPaired) {
                    if (allUnwound) {
                        replicationComplete = true;
                        statusBar.textContent = 'DNA复制完成！正在形成新的双螺旋结构...';

                        // 连接所有子链线段
                        connectNewStrands();

                        setTimeout(() => {
                            formNewHelices();
                            successMessage.style.display = 'block';
                        }, 1500);
                    } else {
                        statusBar.textContent = '当前区域复制完成，请继续拖拽解旋酶以解旋更多DNA区域';
                    }
                }
            }

            // 连接新链线段 (修正后)
            function connectNewStrands() {
                // 移除旧的连接线，避免重复绘制
                document.querySelectorAll('.new-strand-bond').forEach(line => line.remove());

                const startX = 100;
                const centerY = 200;
                const strandDistance = 150;
                const spacing = 30;

                // 连接与模板链配对的新链 (蓝色)
                let y1 = centerY + strandDistance / 2 - 40;
                for (let i = 0; i < newTemplateStrand.length - 1; i++) {
                    if (newTemplateStrand[i] && newTemplateStrand[i + 1]) {
                        const bond = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        bond.setAttribute('x1', startX + i * spacing);
                        bond.setAttribute('y1', y1);
                        bond.setAttribute('x2', startX + (i + 1) * spacing);
                        bond.setAttribute('y2', y1);
                        bond.setAttribute('stroke', '#3498db');
                        bond.setAttribute('stroke-width', '3');
                        bond.setAttribute('class', 'new-strand-bond');
                        unwoundSvg.insertBefore(bond, unwoundSvg.firstChild);
                    }
                }

                // 连接与编码链配对的新链 (红色)
                let y2 = centerY - strandDistance / 2 + 40;
                for (let i = 0; i < newCodingStrand.length - 1; i++) {
                    if (newCodingStrand[i] && newCodingStrand[i + 1]) {
                        const bond = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        bond.setAttribute('x1', startX + i * spacing);
                        bond.setAttribute('y1', y2);
                        bond.setAttribute('x2', startX + (i + 1) * spacing);
                        bond.setAttribute('y2', y2);
                        bond.setAttribute('stroke', '#e74c3c');
                        bond.setAttribute('stroke-width', '3');
                        bond.setAttribute('class', 'new-strand-bond');
                        unwoundSvg.insertBefore(bond, unwoundSvg.firstChild);
                    }
                }
            }


            // 形成新的双螺旋
            function formNewHelices() {
                unwoundArea.style.display = 'none';
                dnaSvg.style.display = 'block';
                dnaSvg.innerHTML = '';

                const { radius, turns, segments } = config.helix;
                const centerX = dnaContainer.clientWidth / 2;
                const centerY1 = 150;  // 上方双螺旋中心
                const centerY2 = 450;  // 下方双螺旋中心

                // 第一条新DNA (原始编码链 + 新模板链) - 上方
                drawNewHelix(centerX, centerY1, '#e74c3c', '#3498db');

                // 第二条新DNA (原始模板链 + 新编码链) - 下方
                drawNewHelix(centerX, centerY2, '#3498db', '#e74c3c');

                statusBar.textContent = 'DNA复制成功！点击"重置模拟"按钮重新开始';
            }

            // 绘制新的双螺旋
            function drawNewHelix(centerX, centerY, strand1Color, strand2Color) {
                const { radius, turns, segments } = config.helix;

                // 创建第一条螺旋路径
                const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData1 = '';

                // 创建第二条螺旋路径
                const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData2 = '';

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const angle = t * 2 * Math.PI * turns;
                    const x = centerX - 150 + t * 300; // 水平方向

                    // 第一条螺旋
                    const y1 = centerY + radius * Math.cos(angle);
                    const z1 = radius * Math.sin(angle);

                    // 第二条螺旋 (与第一条相位差180度)
                    const y2 = centerY + radius * Math.cos(angle + Math.PI);
                    const z2 = radius * Math.sin(angle + Math.PI);

                    // 透视投影
                    const scale1 = 1 - z1 / 400;
                    const scale2 = 1 - z2 / 400;

                    const py1 = centerY + (y1 - centerY) * scale1;
                    const py2 = centerY + (y2 - centerY) * scale2;

                    if (i === 0) {
                        pathData1 += 'M' + x + ',' + py1;
                        pathData2 += 'M' + x + ',' + py2;
                    } else {
                        pathData1 += ' L' + x + ',' + py1;
                        pathData2 += ' L' + x + ',' + py2;
                    }
                }

                // 设置第一条路径属性
                path1.setAttribute('d', pathData1);
                path1.setAttribute('stroke', strand1Color);
                path1.setAttribute('stroke-width', '4');
                path1.setAttribute('fill', 'none');
                dnaSvg.appendChild(path1);

                // 设置第二条路径属性
                path2.setAttribute('d', pathData2);
                path2.setAttribute('stroke', strand2Color);
                path2.setAttribute('stroke-width', '4');
                path2.setAttribute('fill', 'none');
                dnaSvg.appendChild(path2);

                // 添加连接线
                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const angle = t * 2 * Math.PI * turns;
                    const x = centerX - 150 + t * 300;

                    // 第一条螺旋点
                    const y1 = centerY + radius * Math.cos(angle);
                    const z1 = radius * Math.sin(angle);

                    // 第二条螺旋点
                    const y2 = centerY + radius * Math.cos(angle + Math.PI);
                    const z2 = radius * Math.sin(angle + Math.PI);

                    // 透视投影
                    const scale1 = 1 - z1 / 400;
                    const scale2 = 1 - z2 / 400;

                    const py1 = centerY + (y1 - centerY) * scale1;
                    const py2 = centerY + (y2 - centerY) * scale2;

                    // 创建连接线
                    const bond = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    bond.setAttribute('x1', x);
                    bond.setAttribute('y1', py1);
                    bond.setAttribute('x2', x);
                    bond.setAttribute('y2', py2);
                    bond.setAttribute('stroke', 'white');
                    bond.setAttribute('stroke-width', '2');
                    dnaSvg.appendChild(bond);
                }
            }

            // 重置模拟
            function resetSimulation() {
                isUnwound = false;
                replicationComplete = false;
                currentDragging = null;
                templateStrandBases = [];
                codingStrandBases = [];
                newTemplateStrand = [];
                newCodingStrand = [];
                unwoundStart = 0;
                unwoundEnd = 0;

                // 重置视图
                unwoundArea.style.display = 'none';
                dnaSvg.style.display = 'block';
                dnaSvg.innerHTML = ''; // 清空SVG内容
                successMessage.style.display = 'none';
                drawHelix(); // 重新绘制双螺旋

                // 重置状态
                statusBar.textContent = '准备就绪：请将DNA解旋酶拖拽到DNA双螺旋结构上开始复制过程';
            }
        });
    </script>
</body>
</html>